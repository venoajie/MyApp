#!/usr/bin/python3
# -*- coding: utf-8 -*-
#
# built ins
from datetime import datetime, timedelta
import aioschedule as schedule
import asyncio
import json
import os
import tomli
# installed
import websockets
import orjson
from loguru import logger as log

# user defined formula

from utilities.number_modification import get_closest_value
from utilities.pickling import (
    replace_data,
    read_data)
from utilities.system_tools import (
    provide_path_for_file,
    raise_error_message,
    catch_error_message)
from utilities.string_modification import (
    remove_double_brackets_in_list,
    extract_currency_from_text)
from configuration import id_numbering, config
from db_management.sqlite_management import (
    update_status_data,
    querying_table,
    executing_general_query_with_single_filter,
    executing_query_based_on_currency_or_instrument_and_strategy as get_query,
    insert_tables)
from websocket_management.ws_management import (
    resupply_sub_accountdb,
    resupply_transaction_log,
    cancel_the_cancellables,
    if_order_is_true,
    if_cancel_is_true,
    compute_notional_value, 
    check_db_consistencies_and_clean_up_imbalances,
    procedures_for_unlabelled_orders,
    )
from websocket_management.allocating_ohlc import (
    ohlc_result_per_time_frame,
    inserting_open_interest)
from strategies.basic_strategy import (
    get_additional_params_for_open_label,
    check_if_id_has_used_before,
    is_everything_consistent,
    get_additional_params_for_futureSpread_transactions)
from strategies import  hedging_spot
from strategies.config_strategies import (hedging_spot_attributes)
from deribit_get import telegram_bot_sendtext, get_server_time,get_currencies,get_instruments
from configuration.label_numbering import get_now_unix_time
from websocket_management.cleaning_up_transactions import (
    clean_up_closed_transactions,
    remove_duplicated_elements,
    check_if_transaction_has_closed_label_before
)

def deribit_url_main() -> str:
    return "https://www.deribit.com/api/v2/"

def parse_dotenv(sub_account) -> dict:
    return config.main_dotenv(sub_account)

def reading_from_pkl_data(end_point, currency, status: str = None) -> dict:
    """ """

    path: str = provide_path_for_file(end_point, currency, status)

    data = read_data(path)

    return data


def get_trading_config(file_name: str = "config_strategies.toml") -> list:
    """ """
    config_path = provide_path_for_file (file_name)
    
    try:
        if os.path.exists(config_path):
            with open(config_path, "rb") as handle:
                read= tomli.load(handle)
                return read ["tradable"]
    except:
        return []


async def telegram_bot_sendtext(bot_message, purpose: str = "general_error") -> None:

    return await telegram_bot_sendtext(bot_message, purpose)

async def convert_status_has_closed_label_from_no_to_yes(instrument_name, filter_trade, trade_id) -> None:

    transactions_all: list = await executing_general_query_with_single_filter("my_trades_all_json", instrument_name)

    has_closed_label = check_if_transaction_has_closed_label_before (transactions_all, trade_id)
    
    if not has_closed_label or has_closed_label==0:
        
        new_value=True
        data_column= "has_closed_label"
        table= "my_trades_all_json"
        await update_status_data(table, data_column, filter_trade, trade_id, new_value)

async def current_server_time() -> float:
    """ """
    current_time = await get_server_time()
    return current_time["result"]


async def get_futures_for_active_currencies () -> list:
    """_summary_

    Returns:
        list: _description_
    """
    from strategies.basic_strategy import get_instruments_kind
    
    currencies = get_trading_config() ["spot"]
    
    #log.error (f"currencies {currencies}")
    
    instruments_holder_place= []
    for currency in currencies:

        future_instruments= get_instruments_kind (currency,"future" )
        
        instruments_holder_place.append(future_instruments)    
    
    #removing inner list 
    # typical result: [['BTC-30AUG24', 'BTC-6SEP24', 'BTC-27SEP24', 'BTC-27DEC24', 
    # 'BTC-28MAR25', 'BTC-27JUN25', 'BTC-PERPETUAL'], ['ETH-30AUG24', 'ETH-6SEP24', 
    # 'ETH-27SEP24', 'ETH-27DEC24', 'ETH-28MAR25', 'ETH-27JUN25', 'ETH-PERPETUAL']]
    instruments_holder_plc= []
    for instr in instruments_holder_place:
        instruments_holder_plc.append(instr)

    return remove_double_brackets_in_list(instruments_holder_plc)
    
    
async def get_instruments_name () -> list:
    
    active_currencies=  await get_futures_for_active_currencies()

    return [o["instrument_name"] for o in active_currencies]
    
def currency_inline_with_database_address (currency: str, database_address: str) -> bool:
    return currency.lower()  in str(database_address)


async def get_and_save_currencies()->None:
    
    connection_url: str = deribit_url_main()

    try:

        get_currencies_all = await get_currencies(connection_url)
        
        currencies = [o["currency"] for o in get_currencies_all["result"]]
        
        for currency in currencies:

            instruments = await get_instruments(connection_url, currency)

            my_path_instruments = provide_path_for_file("instruments", currency)

            replace_data(my_path_instruments, instruments)

        my_path_cur = provide_path_for_file("currencies")

        replace_data(my_path_cur, currencies)
        # catch_error('update currencies and instruments')

    except Exception as error:
        catch_error_message(
        error, 10, "app"
        )
        
        
async def manage_trades (trades: dict) -> None:

    for trade in trades:
        filter_trade="trade_id"
        order_id=trade["order_id"]
        trade_id=trade[f"{filter_trade}"]
        
        instrument_name= trade["instrument_name"]
        currency=extract_currency_from_text(instrument_name).upper()

        if "label" not in trade :
            label=None
            await get_additional_params_for_open_label (trade, label)
            
        if "combo_id" in trade:
            await get_additional_params_for_futureSpread_transactions(trade)
        
        # FS: 'instrument_name': 'ETH-FS-23AUG24_PERP' (ticker for future spread instrument)
        if f"{currency.upper}-FS-" not in instrument_name:
                
            label=trade["label"]

            trade_id_has_exist_before= await check_if_id_has_used_before (instrument_name, "trade_id", trade_id, 100)
            log.info(f"trade_id_has_exist_before {trade_id_has_exist_before}")
            order_id_has_exist_before= await check_if_id_has_used_before (instrument_name, "order_id", order_id, 100)
            log.info(f"order_id_has_exist_before {order_id_has_exist_before}")
            label_id_has_exist_before= await check_if_id_has_used_before (instrument_name, "label", label, 100)
            log.info(f"label_id_has_exist_before {label_id_has_exist_before}")
            label_has_exist_before= (sum(trade_id_has_exist_before+order_id_has_exist_before+label_id_has_exist_before)!=0)


            log.info(f"trade {trade} order_has_sent_before {label_has_exist_before} not {not label_has_exist_before}")

            if not label_has_exist_before:
                try:
                        
                    if "open" in label:
                        await get_additional_params_for_open_label (trade, label)

                    if "closed" in label:
                        await convert_status_has_closed_label_from_no_to_yes(instrument_name,  filter_trade, trade_id)

                except:
                    log.critical(f"except trade {trade}")
                    
                await insert_tables("my_trades_all_json", trade)
                
                if "closed" in label:
                    await clean_up_closed_transactions (instrument_name)
                    
        
async def manage_positions (positions: dict, currency: str) -> None:

    my_path_position = provide_path_for_file("positions", currency)
    #log.error(f"{str(my_path_position)} {currency.lower()} {currency_inline_with_database_address(currency,my_path_position)}")
    
    if currency_inline_with_database_address(currency,my_path_position):
        replace_data(my_path_position, positions)
        
async def update_portfolio(data_orders, currency) -> None:

    my_path_portfolio = provide_path_for_file("portfolio", currency)
    
    if currency_inline_with_database_address(currency,my_path_portfolio):
        replace_data(my_path_portfolio, data_orders)

async def update_user_changes(data_orders, currency) -> None:
    
    log.info(f"update_user_changes-START")
    #log.info (data_orders)

    positions = data_orders["positions"]
    trades = data_orders["trades"]
    orders = data_orders["orders"]
    
    if trades:
        log.error (f"trades {trades}")
        
        await manage_trades (trades)
        
    if orders:
        from transaction_management.deribit.open_orders_management import manage_orders
            
        log.error (f"orders {orders}")
        
        for order in orders:

            #label=order["label"]
                        
            instrument_name=order["instrument_name"]
            
            log.debug (order)
            log.error (order["label"]=="" )
            order_id=order["order_id"]
            label=order["label"]
            
            if  label =="" :                
                
                await procedures_for_unlabelled_orders(order, instrument_name)

            else:
    
                label_has_exist_before= await check_if_id_has_used_before (instrument_name,"order_id",order_id, 100)
                
                await manage_orders (order)            

                if label_has_exist_before:
                    await cancel_the_cancellables()
    
            everything_consistent= is_everything_consistent(order)
            log.critical (f' ORDERS everything_consistent {everything_consistent} everything_NOT_consistent {not everything_consistent}')
            
            if  not everything_consistent:
                await cancel_the_cancellables()
                await telegram_bot_sendtext('size or open order is inconsistent', "general_error")

    if positions:
        #log.debug (f"positions {positions}")
        await manage_positions (positions, currency)
        
    await remove_duplicated_elements()
    log.info(f"update_user_changes-END")


async def on_restart() -> None:
    """
    """

    log.warning("Cancelling selected orders")
    await cancel_the_cancellables()

class StreamAccountData:

    """

    +----------------------------------------------------------------------------------------------+
    +----------------------------------------------------------------------------------------------+

    """

    def __init__(self, client_id: str, client_secret: str, live=True) -> None:
        # Async Event Loop
        self.loop = asyncio.get_event_loop()

        if not live:
            self.ws_connection_url: str = "wss://test.deribit.com/ws/api/v2"
        elif live:
            self.ws_connection_url: str = "wss://www.deribit.com/ws/api/v2"
        else:
            raise Exception("live must be a bool, True=real, False=paper")

        # Instance Variables
        self.connection_url: str = (
            deribit_url_main()
            if "test" not in self.ws_connection_url
            else "https://test.deribit.com/api/v2/"
        )
        self.client_id: str = client_id
        self.client_secret: str = client_secret
        self.websocket_client: websockets.WebSocketClientProtocol = None
        self.refresh_token: str = None
        self.refresh_token_expiry_time: int = None
    
        # Start Primary Coroutine
        self.loop.run_until_complete(self.ws_manager())

    # @lru_cache(maxsize=None)
    async def ws_manager(self) -> None:
        
        async with websockets.connect(
            self.ws_connection_url,
            ping_interval=None,
            compression=None,
            close_timeout=60,
        ) as self.websocket_client:
            
            while True:
                
                # Authenticate WebSocket Connection
                await self.ws_auth()

                # Establish restart procedure
                #
                # await self.on_restart()
                
                # Establish Heartbeat
                await self.establish_heartbeat()

                # Start Authentication Refresh Task
                self.loop.create_task(self.ws_refresh_auth())
                
                # refresh databases
                await get_and_save_currencies()

                currencies_default = get_trading_config() ["spot"]

                instruments_name=await get_instruments_name()                    
            
                strategy_label= hedging_spot_attributes()[0]["strategy"]       
                 
                for currency in currencies_default:
                    """
                    log.debug (f"currency {currency}")
                    first_tick_fr_sqlite= 1720107788642
                    transaction_log= await get_transaction_log (currency, 
                                                first_tick_fr_sqlite-1, 
                                                1000)
                    
                    column_list: str= "trade_id","label"
                    
                    from_sqlite_open= await get_query("my_trades_all_json", 
                                                    currency, 
                                                    "all", 
                                                    "all", 
                                                    column_list)                                       

                    from_sqlite_closed = await get_query("my_trades_closed_json", 
                                                        currency, 
                                                        "all", 
                                                        "all", 
                                                        column_list,
                                                        300, 
                                                        "id")    
                    
                    combine=from_sqlite_closed + from_sqlite_open
                    for transaction in transaction_log:
                        transaction=remove_dict_elements(transaction,"info")
                        trade_id= transaction["trade_id"]
                        label= [ o for o in combine if o["trade_id"]==trade_id]
                        log.info (f"transaction {transaction}")
                        log.error (f"label {label}")
                        if label !=[]:
                            transaction.update ({"label":label[0]})

                        else:
                            type_trade= transaction["type"]
                            log.error (f"type {type_trade}")
                            timestamp= transaction["timestamp"]
                            log.error (f"timestamp {timestamp}")
                            label= f"custom{type_trade.title()}-{timestamp})"
                            transaction.update ({"label":label})
                        log.error (f"transaction {transaction}")
                        
                        table= f"transaction_log_{currency.lower()}_json"
                        
                        await insert_tables(table, transaction)
                    """
                    await resupply_transaction_log(currency)
                    await resupply_sub_accountdb(currency)
                    
                    #await check_db_consistencies_and_clean_up_imbalances(currency) 
                
                
                for instrument in instruments_name:
                    #log.debug(f"instrument {instrument}")
                    
                    await clean_up_closed_transactions (instrument)

                    currency = extract_currency_from_text(instrument).upper()   
                                    
                    self.loop.create_task(
                        self.ws_operation(
                            operation="subscribe",
                            ws_channel=f"incremental_ticker.{instrument}",
                        )
                    )

                
                    if "PERPETUAL" in instrument:

                        self.loop.create_task(
                            self.ws_operation(
                                operation="subscribe", ws_channel=f"user.portfolio.{currency}"
                            )
                        )

                        self.loop.create_task(
                            self.ws_operation(
                                operation="subscribe",
                                ws_channel=f"user.changes.any.{currency.upper()}.raw",
                            )
                        )
                    
                        self.loop.create_task(
                            self.ws_operation(
                                operation="subscribe",
                                ws_channel=f"chart.trades.{instrument}.1",
                            )
                        )
                        self.loop.create_task(
                            self.ws_operation(
                                operation="subscribe",
                                ws_channel=f"chart.trades.{instrument}.30",
                            )
                        )
                        self.loop.create_task(
                            self.ws_operation(
                                operation="subscribe",
                                ws_channel=f"chart.trades.{instrument}.60",
                            )
                        )
                        self.loop.create_task(
                            self.ws_operation(
                                operation="subscribe",
                                ws_channel=f"chart.trades.{instrument}.1D",
                            )
                        )
                        
                while self.websocket_client.open:
                    # Receive WebSocket messages
                    message: bytes = await self.websocket_client.recv()
                    message: dict = orjson.loads(message)
                    message_channel: str = None
                    #log.warning (message)
                    if "id" in list(message):
                        if message["id"] == 9929:
                            
                            if self.refresh_token is None:

                                log.info("Successfully authenticated WebSocket Connection")

                            else:
                                log.info(
                                    "Successfully refreshed the authentication of the WebSocket Connection"
                                )

                            self.refresh_token = message["result"]["refresh_token"]

                            # Refresh Authentication well before the required datetime
                            if message["testnet"]:
                                expires_in: int = 300
                            else:
                                expires_in: int = message["result"]["expires_in"] - 240

                            self.refresh_token_expiry_time = datetime.utcnow() + timedelta(
                                seconds=expires_in
                            )

                        elif message["id"] == 8212:
                            # Avoid logging Heartbeat messages
                            continue

                    elif "method" in list(message):

                        # Respond to Heartbeat Message
                        if message["method"] == "heartbeat":
                            await self.heartbeat_response()

                    if "params" in list(message):
                        if message["method"] != "heartbeat":
                            message_channel = message["params"]["channel"]

                            data_orders: list = message["params"]["data"]       
                            
                            currency: str = extract_currency_from_text(
                                message_channel
                            )
                            
                            currency_lower=currency
                            currency_upper=currency.upper()

                            if message_channel == f"user.portfolio.{currency.lower()}":
                                # also always performed at restart                                
                                await update_portfolio(data_orders, currency)

                                await resupply_sub_accountdb(currency)    

                            if (message_channel== f"user.changes.any.{currency.upper()}.raw"):
                                
                                await update_user_changes(data_orders, currency)
                                
                                await resupply_transaction_log(currency)
                                await resupply_sub_accountdb(currency)
                                await check_db_consistencies_and_clean_up_imbalances(currency)                           
                            
                            TABLE_OHLC1: str = f"ohlc1_{currency_lower}_perp_json"
                            TABLE_OHLC30: str = f"ohlc30_{currency_lower}_perp_json"
                            TABLE_OHLC60: str = f"ohlc60_{currency_lower}_perp_json"
                            TABLE_OHLC1D: str = f"ohlc1D_{currency_lower}_perp_json"
                            WHERE_FILTER_TICK: str = "tick"
                            DATABASE: str = "databases/trading.sqlite3"
                                                        
                            if "chart.trades" in message_channel:
                                instrument_ticker = ((message_channel)[13:]).partition('.')[0] 
                                                                
                                await ohlc_result_per_time_frame(message_channel, 
                                                                 instrument_ticker,
                                                                data_orders,
                                                                TABLE_OHLC1,
                                                                TABLE_OHLC30,
                                                                TABLE_OHLC60,
                                                                TABLE_OHLC1D,
                                                                WHERE_FILTER_TICK,
                                                                DATABASE
                                                                )
                            instrument_ticker = (message_channel)[19:]                  
                            if (
                                message_channel
                                == f"incremental_ticker.{instrument_ticker}"
                            ):
                                
                                my_path_ticker = provide_path_for_file(
                                    "ticker", instrument_ticker
                                )
                                
                                await self.distribute_ticker_result_as_per_data_type(
                                    my_path_ticker, data_orders, instrument_ticker
                                )
                                            
                                try:
                                    
                                    if "PERPETUAL" in data_orders["instrument_name"]:
                                        
                                        await inserting_open_interest(currency, DATABASE, WHERE_FILTER_TICK, TABLE_OHLC1, data_orders)
                                            
                                        try:                                          
                                                                                        
                                            #log.critical (f" OPENING HEDGING-START-{instrument_ticker.upper()}")
                                                                                      
                                            TA_result_data_all = await querying_table("market_analytics_json")

                                            TA_result_data_only=  TA_result_data_all["list_data_only"]
                                            
                                            TA_result_data = [o for o in TA_result_data_only if currency_upper in o["instrument"]]
                                                                                                    
                                            
                                            ticker= reading_from_pkl_data("ticker",instrument_ticker)
                                            
                                            try:
                                                ticker= ticker[0]
                                            except:
                                                ticker= []
                                                                                            
                                            if ticker !=[]:
                                                        
                                                try:
                                                    index_price= data_orders["index_price"]
                                                    
                                                except:
                                                    
                                                    index_price= ticker["index_price"]
                                                    
                                                    if index_price==[]:
                                                        index_price = ticker ["estimated_delivery_price"]
                                                    #log.critical (f"index_price {index_price}")
                                                    
                                                # get portfolio data  
                                                portfolio= reading_from_pkl_data("portfolio",currency)
                                                
                                                column_list: str= "instrument_name","label", "amount", "price","side","has_closed_label"
                                                
                                                my_trades_instrument: list= await get_query("my_trades_all_json", instrument_ticker, "all", "all", column_list)

                                                # obtain spot equity
                                                equity: float = portfolio[0]["equity"]                                   
                                                                                    
                                                if ticker !=[] and index_price is not None and equity >0:
                                                
                                                    tick_TA=  max([o["tick"] for o in TA_result_data])
                                                    
                                                    server_time=     get_now_unix_time()  
                                                    
                                                    delta_time= server_time-tick_TA
                                                    
                                                    delta_time_seconds=delta_time/1000                                                
                                                    
                                                    #log.debug (f" delta_time_seconds {delta_time_seconds} tick_TA {tick_TA} server_time {server_time} {delta_time_seconds<120}")

                                                    if delta_time_seconds < 120:#ensure freshness of ta
                                                        
                                                        notional: float = compute_notional_value(index_price, equity)
                                                            
                                                        best_ask_prc: float = ticker["best_ask_price"]                                                    
                                                        
                                                        hedging = hedging_spot.HedgingSpot(strategy_label)
                                                        #log.warning (f"A")
                                                        
                                                        send_order: dict = (
                                                        await hedging.is_send_and_cancel_open_order_allowed(
                                                            currency,
                                                            instrument_ticker,
                                                            notional,
                                                            index_price,
                                                            best_ask_prc,
                                                            server_time,
                                                            TA_result_data
                                                        )
                                                    )
                                                        
                                                        #log.warning (f"A")
                                                        #log.debug(f"if_order_is_true {send_order} {instrument_ticker} ")
                                                        
                                                        if send_order["order_allowed"]:
                                                            await if_order_is_true(send_order, instrument_ticker)
                                                            await if_cancel_is_true(send_order)

                                                        #log.critical (f"OPENING HEDGING-DONE")                                                                                                 
                                                        
                                                        my_trades_open_hedging = [o for o in my_trades_instrument if "open" in (o["label"])\
                                                            and "hedgingSpot" in (o["label"]) ]

                                                        if my_trades_open_hedging !=[]:
                                                        
                                                        #    log.critical (f"CLOSING HEDGING-START {instrument_ticker}")
                                                                        
                                                            best_bid_prc: float = ticker["best_bid_price"]
                                                            
                                                            get_prices_in_label_transaction_main = [o["price"] for o in my_trades_open_hedging]

                                                            closest_price = get_closest_value(get_prices_in_label_transaction_main, best_bid_prc)

                                                            nearest_transaction_to_index = [o for o in my_trades_open_hedging if o["price"] == closest_price]
                                                            log.debug (f"nearest_transaction_to_index {nearest_transaction_to_index}")
                                                            
                                                            send_closing_order: dict = await hedging.is_send_exit_order_allowed(
                                                                TA_result_data,
                                                                index_price,
                                                                best_ask_prc,
                                                                best_bid_prc,
                                                                nearest_transaction_to_index,
                                                            )
                                                            log.error (f"send_closing_order {send_closing_order}")
                                                            await if_order_is_true(send_closing_order, instrument_ticker)
                                                            await if_cancel_is_true(send_closing_order)

                                                    #log.critical (f"CLOSING HEDGING-DONE")
                                                    
                                            
                                        except ValueError:
                                            import traceback
                                            traceback.format_exc()
                                            log.info(f" error {error}")
                                            #continue
                                                                
                                except Exception as error:
                                    log.error(error)
                                    await raise_error_message(
                                        "WebSocket connection - failed to process data"
                                    )

                                    #continue
                                    
                else:
                
                    log.info("WebSocket connection has broken.")
                    await raise_error_message(
                        "error-WebSocket connection EXCHANGE has broken",
                        0.1,
                        "WebSocket connection EXCHANGE has broken",
                    )
        
                    # Establish restart procedure
                    await on_restart()
                
    async def distribute_ticker_result_as_per_data_type(
        self, my_path_ticker, data_orders, instrument
    ) -> None:
        """ """

        try:
            
            if data_orders["type"] == "snapshot":
                replace_data(my_path_ticker, data_orders)

            else:
                ticker_change: list = read_data(my_path_ticker)
                if ticker_change != []:
                    
                    for item in data_orders:
                        ticker_change[0][item] = data_orders[item]
                        replace_data(my_path_ticker, ticker_change)

        except Exception as error:
            await raise_error_message(
                error,
                "WebSocket connection - failed to distribute_incremental_ticker_result_as_per_data_type",
            )

    async def on_restart_(self) -> None:
        """
        """

        log.warning("Cancelling all orders")
        await cancel_the_cancellables()
        #msg= deribit_get.get_cancel_order_all()
        #await self.websocket_client.send(json.dumps(msg))
        
    async def establish_heartbeat(self) -> None:
        """
        Requests DBT's `public/set_heartbeat` to
        establish a heartbeat connection.
        """
        msg: dict = {
            "jsonrpc": "2.0",
            "id": 9098,
            "method": "public/set_heartbeat",
            "params": {"interval": 10},
        }

        try:
            await self.websocket_client.send(json.dumps(msg))
        except Exception as error:
            log.warning(error)

    async def heartbeat_response(self) -> None:
        """
        Sends the required WebSocket response to
        the Deribit API Heartbeat message.
        """
        msg: dict = {
            "jsonrpc": "2.0",
            "id": 8212,
            "method": "public/test",
            "params": {},
        }

        try:
            await self.websocket_client.send(json.dumps(msg))

        except Exception as error:
            log.warning(error)

    async def ws_auth(self) -> None:
        """
        Requests DBT's `public/auth` to
        authenticate the WebSocket Connection.
        """
        msg: dict = {
            "jsonrpc": "2.0",
            "id": 9929,
            "method": "public/auth",
            "params": {
                "grant_type": "client_credentials",
                "client_id": self.client_id,
                "client_secret": self.client_secret,
            },
        }
        
        await self.websocket_client.send(json.dumps(msg))

    async def ws_refresh_auth(self) -> None:
        """
        Requests DBT's `public/auth` to refresh
        the WebSocket Connection's authentication.
        """
        while True:
            if self.refresh_token_expiry_time is not None:
                if datetime.utcnow() > self.refresh_token_expiry_time:
                    msg: dict = {
                        "jsonrpc": "2.0",
                        "id": 9929,
                        "method": "public/auth",
                        "params": {
                            "grant_type": "refresh_token",
                            "refresh_token": self.refresh_token,
                        },
                    }

                    await self.websocket_client.send(json.dumps(msg))

            await asyncio.sleep(150)

    async def ws_operation(
        self, operation: str, ws_channel: str, id: int = 100
    ) -> None:
        """
        Requests `public/subscribe` or `public/unsubscribe`
        to DBT's API for the specific WebSocket Channel.
        """
        await asyncio.sleep(5)

        id = id_numbering.id(operation, ws_channel)

        msg: dict = {
            "jsonrpc": "2.0",
            "method": f"private/{operation}",
            "id": id,
            "params": {"channels": [ws_channel]},
        }

        await self.websocket_client.send(json.dumps(msg))


def main():
    """
    https://stackoverflow.com/questions/70880668/is-it-possible-to-iterate-a-list-calling-async-function
    https://stackoverflow.com/questions/56161595/how-to-use-async-for-in-python
    """
    # https://www.codementor.io/@jflevesque/python-asynchronous-programming-with-asyncio-library-eq93hghoc
    sub_account = "deribit-147691"
    client_id: str = parse_dotenv(sub_account)["client_id"]
    client_secret: str = parse_dotenv(sub_account)["client_secret"]   

    try:

        StreamAccountData(client_id=client_id, client_secret=client_secret)
        
        #async with websockets.connect(
        #    "wss://test.deribit.com/ws/api/v2",
        #    ping_interval=None,
        #    compression=None,
        #    close_timeout=60,
        #) as websocket_client:
        
        #    await stream.ws_auth()
                
        #task_list = []
        #for currency in currencies:
        #    task_list.append(asyncio.create_task(stream.ws_manager(instruments_name)))
        #    log.critical(f"currency {currency}")

        #await asyncio.gather(*task_list)

    except Exception as error:
        asyncio.run(cancel_the_cancellables())
        catch_error_message(
            error, 10, "app"
        )
        
if __name__ == "__main__":
    try:
        
        main()
        #asyncio.run(main())
        
        while True:
            loop.run_until_complete(schedule.run_pending())

    except (KeyboardInterrupt, SystemExit):

        asyncio.get_event_loop().run_until_complete(main().stop_ws())
        
    except Exception as error:
                
        catch_error_message(
        error, 10, "app"
        )
